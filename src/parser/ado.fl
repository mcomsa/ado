%option noyywrap nostdinit never-interactive ecs
%option bison-bridge reentrant
%option stack

%{ /* -*- C++ -*- */
#include <algorithm>
#include <stack>
#include <vector>
#include <sstream>
#include <string>

#include <Rcpp.h>

#include "Ado.hpp"
#include "ado.tab.hpp"

#ifndef YYSTYPE
#define YYSTYPE yy::AdoParser::semantic_type
#endif

// We really, really can't have the scanner calling exit() and
// killing the R process, so let's use our own friendlier routine.
// If the issue is memory exhaustion, the R interpreter overall will
// have run out of memory and will handle it however it's going to.
#ifdef YY_FATAL_ERROR
#undef YY_FATAL_ERROR
#endif

#define YY_FATAL_ERROR(msg) ado_yy_fatal_error(msg)

// Make yytext big enough to hold a macro replacement text as large as
// the ones Stata allows
#ifdef YYLMAX
#undef YYLMAX
#endif

#define YYLMAX 65536

// our error handling routine for fatal errors, defined below
void ado_yy_fatal_error(const char *msg);

// String utilities only used here
std::vector<std::string> split(const std::string &s, char delim);
std::vector<std::string> &split(const std::string &s, char delim,
                                std::vector<std::string> &elems);
std::string trim(const std::string& str, const std::string& what = " ");

typedef yy::AdoParser::token token;

// How to get macro expansions from R
#define R_MACRO_VALUE(name) driver.get_macro_value(name);

// How to report errors to R for further processing
#define R_ERROR(val) driver.error(llocp->begin.line, llocp->begin.column, val);

// Should we echo the matched text? It's necessary for
// logging and for printing commands run in do-files.
#define R_ECHO(val) { \
                        std::string tmp = std::string(val); \
                        \
                        if(tmp.length() >= macro_length) \
                        { \
                            tmp = tmp.erase(0, macro_length); \
                            macro_length = 0; \
                            driver.push_echo_text(tmp); \
                        } else \
                        { \
                            macro_length -= tmp.length(); \
                        } \
                        \
                    }

// Code run each time a pattern is matched
#define YY_USER_ACTION  { llocp->columns(yyleng); }
%}

%array

%x LONG_COMMENT
%x SHORT_COMMENT

%x LOCAL_MACRO

%x GMACRO_ALPHA
%x GMACRO_BRACE

%s FOREACH
%s FORVALUES

%x ACCUMULATE
%x STRING_ACCUMULATE
%x CDQUOTE_ACCUMULATE

%x EMBED
%x STRING
%x CDQUOTE

D           [0-9]
L           [a-zA-Z_]
H           [a-fA-F0-9]
E           [Ee][+-]?{D}+
F           [FLfl]
M           (?i:(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))
B           [ \t\v\r\f]
T           [A-Za-z\.\,\:\-\_\/\\\+]

%%

%{
// Code run each time yylex is called
llocp->step();

// Buffers and stacks for state machines
std::string embed_buf;
std::string cdquote_buf;
std::string string_buf;

// Loop objects
std::string loop_buf;
int brace_count = 0;

std::stack<std::vector<std::string>> macro_stack;

// We don't want to echo text resulting from macro expansions, so
// let's keep track of how much of it there is so the R_ECHO macro can
// avoid outputting it.
size_t macro_length = 0;
%}
                                    /* if you write {{{ ... }}}, the ... will be executed as R code */
<INITIAL>"{{{"                      {
                                        R_ECHO(yytext);
                                        
                                        embed_buf.clear();
                                        yy_push_state(EMBED, yyscanner);
                                    }
<EMBED>{
    "}}}"                           {
                                        R_ECHO(yytext);
                                        
                                        yy_pop_state(yyscanner);

                                        ExprNode *node = new ExprNode("ado_embedded_code");
                                        node->addData("value", std::string(embed_buf));
                                        node->addData("lang", "R");

                                        yylval->node = node;
                                        return token::TOK_EMBEDDED_CODE;
                                    }
    
    [\n]+                           {
                                        R_ECHO(yytext);
                                        
                                        llocp->lines(yyleng);
                                        embed_buf += std::string(yytext);
                                    }
    \}[^\}]                         { 
                                        R_ECHO(yytext);
                                        
                                        embed_buf += std::string(yytext);
                                    }
    \}\}[^\}]                       {
                                        R_ECHO(yytext);
                                        
                                        embed_buf += std::string(yytext);
                                    }
    [^\}\n]+                        {
                                        R_ECHO(yytext);
                                        
                                        embed_buf += std::string(yytext);
                                    }

    <<EOF>>                         {
                                        embed_buf.clear();
                                        yy_pop_state(yyscanner);
                                        
                                        R_ERROR("Unclosed embed block");
                                        yyterminate();
                                    }
}



                                    /* INITIAL rules to match macros, local and global */
<INITIAL>\`                         {
                                        R_ECHO(yytext);
                                        
                                        while(!macro_stack.empty())
                                            macro_stack.pop();
                                        
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(LOCAL_MACRO, yyscanner);
                                    }
<INITIAL>\$/({L}|{D})+              {
                                        R_ECHO(yytext);
                                        
                                        while(!macro_stack.empty())
                                            macro_stack.pop();
                                        
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(GMACRO_ALPHA, yyscanner);
                                    }
<INITIAL>\$\{                       {
                                        R_ECHO(yytext);
                                        
                                        while(!macro_stack.empty())
                                            macro_stack.pop();
                                        
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(GMACRO_BRACE, yyscanner);
                                    }



                                    /* Rules for while within optionally nested local macros */
<LOCAL_MACRO>{
    \`                              {
                                        R_ECHO(yytext);
                                        
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(LOCAL_MACRO, yyscanner);
                                    }

                                    /* Local macros can't include newlines */
    \n                              {
                                        R_ECHO(yytext);
                                        
                                        llocp->lines(1);
                                        
                                        while(!macro_stack.empty())
                                            macro_stack.pop();
                                        
                                        do {
                                            yy_pop_state(yyscanner);
                                        } while(yy_top_state(yyscanner) != INITIAL);
                                        
                                        R_ERROR("Unclosed local macro");
                                        yyterminate();
                                    }

                                    /* We've reached the matching close quote - let's expand the macro */
    \'                              {
                                        R_ECHO(yytext);
                                        
                                        std::vector<std::string> frame = macro_stack.top();
                                        std::string combined, replacement;
                                        
                                        macro_stack.pop();
                                        
                                        for(size_t i = 0; i < frame.size(); i++)
                                            combined += frame[i];
                                        combined = std::string("_") + combined; // local macros start with a "_"
                                        
                                        replacement = R_MACRO_VALUE(combined);

                                        if(!macro_stack.empty())
                                        {
                                            std::vector<std::string> prev = macro_stack.top();
                                            macro_stack.pop();

                                            prev.push_back(replacement);
                                            macro_stack.push(prev);
                                            
                                            yy_pop_state(yyscanner);
                                        } else
                                        {
                                            for(size_t i = replacement.length(); i > 0; i--)
                                                unput(replacement[i - 1]);

                                            macro_length += replacement.length();
                                            
                                            yy_pop_state(yyscanner);
                                        }
                                    }
    
    \\.                             {
                                        R_ECHO(yytext);
                                        
                                        // push yytext to the back of the current frame
                                        std::vector<std::string> frame = macro_stack.top();
                                        macro_stack.pop();

                                        frame.push_back(std::string(yytext + 1)); // a string w/o the first char
                                        macro_stack.push(frame);
                                    }
    \\                              {
                                        R_ECHO(yytext);
                                        
                                        // push yytext to the back of the current frame
                                        std::vector<std::string> frame = macro_stack.top();
                                        macro_stack.pop();

                                        frame.push_back(std::string("\\"));
                                        macro_stack.push(frame);
                                    }
    \{|\}                           {
                                        // These macros can't contain braces because the braces might
                                        // not be balanced, which would greatly complicate parsing loops
                                        R_ECHO(yytext);
                                        
                                        while(!macro_stack.empty())
                                            macro_stack.pop();
                                        
                                        do {
                                            yy_pop_state(yyscanner);
                                        } while(yy_top_state(yyscanner) != INITIAL);
                                        
                                        R_ERROR("Invalid character in local macro");
                                        yyterminate();
                                    }
    [^\\\`\'\n\{\}]+                {
                                        R_ECHO(yytext);
                                        
                                        // push yytext to the back of the current frame
                                        std::vector<std::string> frame = macro_stack.top();
                                        macro_stack.pop();

                                        frame.push_back(std::string(yytext));
                                        macro_stack.push(frame);
                                    }
   
                                    /* This is an error (failing to close the macro) */
    <<EOF>>                         {
                                        while(!macro_stack.empty())
                                            macro_stack.pop();
                                        
                                        do {
                                            yy_pop_state(yyscanner);
                                        } while(yy_top_state(yyscanner) != INITIAL);
                                        
                                        R_ERROR("Unclosed local macro");
                                        yyterminate();
                                    }
}

                                    /* Rules for global macros of the form \$[:alnum:]+
                                     * This is a bit overcomplicated for just these macros, honestly, but
                                     * it uses the same state machine setup as for the more complicated
                                     * GMACRO_BRACE and LOCAL_MACRO cases, and lets us just push a GMACRO_ALPHA
                                     * state within either of those instead of duplicating this code. */
<GMACRO_ALPHA>{
                                    /* A global macro name that doesn't need to be disambiguated with braces */
    ({L}|{D})+                      {
                                        R_ECHO(yytext);
                                        
                                        // push yytext to the back of the current frame
                                        std::vector<std::string> frame = macro_stack.top();
                                        macro_stack.pop();

                                        frame.push_back(std::string(yytext));
                                        macro_stack.push(frame);
                                    }
   
                                    /* Any other character is a delimiter - we're at the end of the macro */
    [^{L}{D}]|\n                    {
                                        // don't R_ECHO because we're unputting the matched text to process again

                                        if(yytext[0] == '\n')
                                            llocp->lines(1);
                                        
                                        std::vector<std::string> frame = macro_stack.top();
                                        std::string combined, replacement;

                                        macro_stack.pop();
                                        
                                        for(size_t i = 0; i < frame.size(); i++)
                                            combined += frame[i];
                                        
                                        replacement = R_MACRO_VALUE(combined);

                                        if(!macro_stack.empty())
                                        {
                                            std::vector<std::string> prev = macro_stack.top();
                                            macro_stack.pop();

                                            unput(yytext[0]); // we never saw this character
                                            prev.push_back(replacement);
                                            macro_stack.push(prev);
                                            
                                            yy_pop_state(yyscanner);
                                        } else
                                        {
                                            unput(yytext[0]); // we never saw this character
                                            for(size_t i = replacement.length(); i > 0; i--)
                                                unput(replacement[i - 1]);
                                            
                                            macro_length += replacement.length();
                                            
                                            yy_pop_state(yyscanner);
                                        }
                                    }
                                        
                                    /* EOF is also a delimiter, but flex won't allow it in a normal rule */
    <<EOF>>                         {
                                        std::vector<std::string> frame = macro_stack.top();
                                        std::string combined, replacement;

                                        macro_stack.pop();
                                        
                                        for(size_t i = 0; i < frame.size(); i++)
                                            combined += frame[i];
                                        
                                        replacement = R_MACRO_VALUE(combined);

                                        if(!macro_stack.empty())
                                        {
                                            std::vector<std::string> prev = macro_stack.top();
                                            macro_stack.pop();

                                            prev.push_back(replacement);
                                            macro_stack.push(prev);
                                            
                                            yy_pop_state(yyscanner);
                                        } else
                                        {
                                            for(size_t i = replacement.length(); i > 0; i--)
                                                unput(replacement[i - 1]);
                                            
                                            macro_length += replacement.length();
                                            
                                            yy_pop_state(yyscanner);
                                        }
                                    }
}



                                    /* The style of global macro with matching braces to allow other macros
                                     * to be expanded and incorporated into a global's name. */
<GMACRO_BRACE>{
                                    /* Allow any type of macro to be nested here */
    \`                              {
                                        R_ECHO(yytext);
                                        
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(LOCAL_MACRO, yyscanner);
                                    }
    \$/({L}|{D})+                   {
                                        R_ECHO(yytext);
                                        
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(GMACRO_ALPHA, yyscanner);
                                    }
    \$\{                            {
                                        R_ECHO(yytext);
                                        
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(GMACRO_BRACE, yyscanner);
                                    }
    \\.                             {
                                        R_ECHO(yytext);
                                        
                                        // push yytext to the back of the current frame
                                        std::vector<std::string> frame = macro_stack.top();
                                        macro_stack.pop();

                                        frame.push_back(std::string(yytext + 1)); // a string w/o the first char
                                        macro_stack.push(frame);
                                    }
    \\                              {
                                        R_ECHO(yytext);
                                        
                                        // push yytext to the back of the current frame
                                        std::vector<std::string> frame = macro_stack.top();
                                        macro_stack.pop();

                                        frame.push_back(std::string("\\"));
                                        macro_stack.push(frame);
                                    }

    \$                              {
                                        R_ECHO(yytext);
                                        
                                        // push yytext to the back of the current frame
                                        std::vector<std::string> frame = macro_stack.top();
                                        macro_stack.pop();

                                        frame.push_back(std::string(yytext));
                                        macro_stack.push(frame);
                                    }

                                    /* Characters that should be part of the name */
    [^\\\`\$\}\n]+                  {
                                        R_ECHO(yytext);
                                        
                                        // push yytext to the back of the current frame
                                        std::vector<std::string> frame = macro_stack.top();
                                        macro_stack.pop();

                                        frame.push_back(std::string(yytext));
                                        macro_stack.push(frame);
                                    }
   
                                    /* We've seen the closing brace - wrap up and expand this macro */
    \}                              {
                                        R_ECHO(yytext);
                                        
                                        std::vector<std::string> frame = macro_stack.top();
                                        std::string combined, replacement;

                                        macro_stack.pop();
                                        
                                        for(size_t i = 0; i < frame.size(); i++)
                                            combined += frame[i];
                                        
                                        replacement = R_MACRO_VALUE(combined);

                                        if(!macro_stack.empty())
                                        {
                                            std::vector<std::string> prev = macro_stack.top();
                                            macro_stack.pop();

                                            prev.push_back(replacement);
                                            macro_stack.push(prev);
                                            
                                            yy_pop_state(yyscanner);
                                        } else
                                        {
                                            for(size_t i = replacement.length(); i > 0; i--)
                                                unput(replacement[i - 1]);
                                            
                                            macro_length += replacement.length();
                                            
                                            yy_pop_state(yyscanner);
                                        }
                                    }
                                    
                                    /* newline here is an error - these macros can't cross lines */
    \n                              {
                                        R_ECHO(yytext);
                                        
                                        llocp->lines(1);
                                        
                                        while(!macro_stack.empty())
                                            macro_stack.pop();
                                        
                                        do {
                                            yy_pop_state(yyscanner);
                                        } while(yy_top_state(yyscanner) != INITIAL);
                                        
                                        R_ERROR("Unclosed brace-delimited global macro");
                                        yyterminate();
                                    }
                                    
                                    /* EOF here is an error - the user forgot the closing "}" */
    <<EOF>>                         {
                                        while(!macro_stack.empty())
                                            macro_stack.pop();
                                        
                                        do {
                                            yy_pop_state(yyscanner);
                                        } while(yy_top_state(yyscanner) != INITIAL);
                                        
                                        R_ERROR("Unclosed brace-delimited global macro");
                                        yyterminate();
                                    }
}


                                    /* Loops, which in Stata are not loops in the usual sense.
                                     * A Stata loop is a directive to the macro processor (this
                                     * scanner, in this case) to bind a macro name over a set of
                                     * values and for each such value, reparse and execute a block
                                     * of text containing the macro.
                                     
                                     * The basic idea here is this: once we see one of the looping
                                     * keywords foreach or forvalues, specially lex a) the macro name,
                                     * b) the set of values it should range over, c) the block of text
                                     * and pass those things as appropriate tokens to the parser. The parser
                                     * forms the appropriate productions from them, and their associated
                                     * ExprNode objects will be passed up to the R layer for execution. The
                                     * functions that implement them set up the macro context, and for each
                                     * value of the macro, invoke a new parser/scanner instance to reparse
                                     * and execute the text block. If there are nested loops, there can be
                                     * three or more scanners running at once, in interleaved timeslices.
                                     * (That's why it's so important that both the parser and the scanner be
                                     * reentrant, even though R isn't multithreaded.) */
<INITIAL>^{B}*foreach               {
                                        R_ECHO(yytext);

                                        loop_buf.clear();
                                        yy_push_state(FOREACH, yyscanner);

                                        yylval->node = new ExprNode({"ado_loop", "ado_foreach"});
                                        return token::TOK_FOREACH;
                                    }
<INITIAL>^{B}*forvalues             {
                                        R_ECHO(yytext);

                                        loop_buf.clear();
                                        yy_push_state(FORVALUES, yyscanner);

                                        yylval->node = new ExprNode({"ado_loop", "ado_forvalues"});
                                        return token::TOK_FORVALUES;
                                    }
<INITIAL>^{B}*forvalue              {
                                        R_ECHO(yytext);

                                        loop_buf.clear();
                                        yy_push_state(FORVALUES, yyscanner);

                                        yylval->node = new ExprNode({"ado_loop", "ado_forvalues"});
                                        return token::TOK_FORVALUES;
                                    }
<INITIAL>^{B}*forvalu               {
                                        R_ECHO(yytext);

                                        loop_buf.clear();
                                        yy_push_state(FORVALUES, yyscanner);

                                        yylval->node = new ExprNode({"ado_loop", "ado_forvalues"});
                                        return token::TOK_FORVALUES;
                                    }
<INITIAL>^{B}*forval                {
                                        R_ECHO(yytext);

                                        loop_buf.clear();
                                        yy_push_state(FORVALUES, yyscanner);

                                        yylval->node = new ExprNode({"ado_loop", "ado_forvalues"});
                                        return token::TOK_FORVALUES;
                                    }
<INITIAL>^{B}*forva                 {
                                        R_ECHO(yytext);

                                        loop_buf.clear();
                                        yy_push_state(FORVALUES, yyscanner);

                                        yylval->node = new ExprNode({"ado_loop", "ado_forvalues"});
                                        return token::TOK_FORVALUES;
                                    }
<INITIAL>^{B}*forv                  {
                                        R_ECHO(yytext);

                                        loop_buf.clear();
                                        yy_push_state(FORVALUES, yyscanner);

                                        yylval->node = new ExprNode({"ado_loop", "ado_forvalues"});
                                        return token::TOK_FORVALUES;
                                    }



<FOREACH>{
    \{                              {
                                        R_ECHO(yytext);
                                        
                                        loop_buf.clear();
                                        yy_push_state(ACCUMULATE, yyscanner);

                                        yylval->str = new std::string(yytext);
                                        return token::TOK_LBRACE;
                                    }
    local                           {
                                        R_ECHO(yytext);
                                        return token::TOK_LOCAL;
                                    }
    global                          {
                                        R_ECHO(yytext);
                                        return token::TOK_GLOBAL;
                                    }
    varlist                         {
                                        R_ECHO(yytext);
                                        return token::TOK_VARLIST;
                                    }
    newlist                         {
                                        R_ECHO(yytext);
                                        return token::TOK_NEWLIST;
                                    }
    numlist                         {
                                        R_ECHO(yytext);
                                        return token::TOK_NUMLIST;
                                    }
    of                              {
                                        R_ECHO(yytext);
                                        return token::TOK_OF;
                                    }
    <<EOF>>                         {
                                        // getting to EOF in this state is an error
                                        do {
                                            yy_pop_state(yyscanner);
                                        } while(yy_top_state(yyscanner) != INITIAL);
                                        
                                        R_ERROR("Foreach loop without a statement body");
                                        yyterminate();
                                    }
}



<FORVALUES>{
    \{                              {
                                        R_ECHO(yytext);

                                        loop_buf.clear();
                                        yy_push_state(ACCUMULATE, yyscanner);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_LBRACE;
                                    }
    to                              {
                                        R_ECHO(yytext);
                                        return token::TOK_TO;
                                    }
    <<EOF>>                         {
                                        // getting to EOF in this state is an error
                                        do {
                                            yy_pop_state(yyscanner);
                                        } while(yy_top_state(yyscanner) != INITIAL);
                                        
                                        R_ERROR("Foreach loop without a statement body");
                                        yyterminate();
                                    }
}



<ACCUMULATE>{
                                    /* We never need to execute comments, and they can contain unmatched braces,
                                     * so just eat them now, exactly as usual */
    "/*"                            {
                                        R_ECHO(yytext);
                                        yy_push_state(LONG_COMMENT, yyscanner);
                                    }
    "//"                            {
                                        R_ECHO(yytext);
                                        yy_push_state(SHORT_COMMENT, yyscanner);
                                    }
    ^\*                             {
                                        R_ECHO(yytext);
                                        yy_push_state(SHORT_COMMENT, yyscanner);
                                    }
                                    
    \`\"                            {
                                        R_ECHO(yytext);
                                        
                                        cdquote_buf.clear();
                                        yy_push_state(CDQUOTE_ACCUMULATE, yyscanner);
                                    }
                                    
                                    /* Strings may contain unbalanced braces, so we need some subsidiary states
                                     * to handle them without confusing the brace counting code. We can't use the
                                     * usual string states because a) they don't append to loop_buf, but more
                                     * fundamentally because b) they'll process backslash escapes, which in this context
                                     * we want to defer until the subsequent reinvocation of the frontend on this text block. */
    \"                              {
                                        R_ECHO(yytext);
                                        
                                        string_buf.clear();
                                        yy_push_state(STRING_ACCUMULATE, yyscanner);
                                    }
    [\n]+                           {
                                        R_ECHO(yytext);
                                        
                                        llocp->lines(yyleng);
                                        loop_buf += std::string(yytext);
                                    }
    "{"                             {
                                        R_ECHO(yytext);

                                        brace_count++;
                                        loop_buf += yytext[0];
                                    }
    "}"                             {
                                        // don't R_ECHO because we're going to unput the matched text to process again

                                        // This is not a mistake: it should be -1 rather than 0, because the brace_count
                                        // variable is set to 0 when yylex starts up, and we want to see one more closing
                                        // brace than we've seen opening braces. (Its matching opening brace is consumed
                                        // in the FOREACH or FORVALUES states before we get here, but setting brace_count
                                        // there won't persist to this invocation unless we do something not thread-safe 
                                        // and make brace_count static.)
                                        brace_count--;
                                        if(brace_count > -1)
                                        {
                                            loop_buf += yytext[0];
                                        } else if(brace_count == -1)
                                        {
                                            yy_pop_state(yyscanner); // back to FOREACH or FORVALUES
                                            yy_pop_state(yyscanner); // back to INITIAL

                                            unput(yytext[0]); // we want to re-scan this because the parser expects a "}"

                                            // construct a string literal token from loop_buf and return it
                                            std::string *s = new std::string(loop_buf);
                                            yylval->node = new ExprNode({"ado_literal", "ado_string_literal"});
                                            yylval->node->addData("value", *s);

                                            return token::TOK_STRING_LITERAL;
                                        } else // brace_count < -1
                                        {
                                            // too many braces
                                            do {
                                                yy_pop_state(yyscanner);
                                            } while(yy_top_state(yyscanner) != INITIAL);
                                            
                                            R_ERROR("Invalid statement body for loop");
                                            yyterminate();
                                        }
                                    }
    [^\{\}\"\n]+                    {
                                        R_ECHO(yytext);

                                        loop_buf += std::string(yytext);
                                    }

    <<EOF>>                         {
                                        // getting to EOF in this state is an error
                                        do {
                                            yy_pop_state(yyscanner);
                                        } while(yy_top_state(yyscanner) != INITIAL);
                                        
                                        R_ERROR("Loop statement without a closing brace");
                                        yyterminate();
                                    }
}



<STRING_ACCUMULATE>{
                                    /* Saw the matching close quote - all done */
    \"                              {
                                        R_ECHO(yytext);
                                        loop_buf += std::string(yytext);

                                        yy_pop_state(yyscanner);
                                    }

    [\n]+                           {
                                        // getting to EOF in this state is an error
                                        R_ECHO(yytext);
                                        llocp->lines(yyleng);
                                        
                                        do {
                                            yy_pop_state(yyscanner);
                                        } while(yy_top_state(yyscanner) != INITIAL);
                                        
                                        R_ERROR("Unclosed string literal");
                                        yyterminate();
                                    }

    \\\"                            {
                                        R_ECHO(yytext);
                                        loop_buf += std::string(yytext);
                                    }
    \\                              {
                                        R_ECHO(yytext);
                                        loop_buf += std::string(yytext);
                                    }

    [^\\\n\"]+                      {
                                        // this rule is the entire reason for this state - it matches
                                        // opening curly braces but doesn't increment brace_count
                                        R_ECHO(yytext);
                                        loop_buf += std::string(yytext);
                                    }

    <<EOF>>                         {
                                        // getting to EOF in this state is an error
                                        do {
                                            yy_pop_state(yyscanner);
                                        } while(yy_top_state(yyscanner) != INITIAL);
                                        
                                        R_ERROR("Unclosed string literal");
                                        yyterminate();
                                    }
}



<CDQUOTE_ACCUMULATE>{
                                    /* Saw the matching close quote - all done */
    \"\'                            {
                                        R_ECHO(yytext);
                                        loop_buf += std::string(yytext);

                                        yy_pop_state(yyscanner);
                                    }

    \"/[^\']+                       {
                                        R_ECHO(yytext);
                                        loop_buf += std::string(yytext);
                                    }

    [\n]+                           {
                                        // getting to EOF in this state is an error
                                        R_ECHO(yytext);
                                        llocp->lines(yyleng);
                                        
                                        do {
                                            yy_pop_state(yyscanner);
                                        } while(yy_top_state(yyscanner) != INITIAL);
                                        
                                        R_ERROR("Unclosed compound double quote");
                                        yyterminate();
                                    }

    \\\"                            {
                                        R_ECHO(yytext);
                                        loop_buf += std::string(yytext);
                                    }
    \\                              {
                                        R_ECHO(yytext);
                                        loop_buf += std::string(yytext);
                                    }

    [^\\\n\"]+                      {
                                        // once again, the fact that this rule matches the "{" character
                                        // but doesn't increment brace_count is why we have this state
                                        R_ECHO(yytext);
                                        loop_buf += std::string(yytext);
                                    }

    <<EOF>>                         {
                                        // getting to EOF in this state is an error
                                        do {
                                            yy_pop_state(yyscanner);
                                        } while(yy_top_state(yyscanner) != INITIAL);
                                        
                                        R_ERROR("Unclosed compound double quote");
                                        yyterminate();
                                    }
}



                                    /* Eat long comments */
<INITIAL>"/*"                       {
                                        R_ECHO(yytext);
                                        
                                        yy_push_state(LONG_COMMENT, yyscanner);
                                    }
<LONG_COMMENT>{
                                    /* Got a close-comment marker, all done */
    "*/"                            {
                                        R_ECHO(yytext);
                                        
                                        yy_pop_state(yyscanner);
                                    }

    [^\*\n]+                        {
                                        R_ECHO(yytext);
                                        
                                        /* Eat this chunk of comment */
                                    }
    \*                              {
                                        R_ECHO(yytext);
                                        
                                        /* Eat a single asterisk */
                                    }
    [\n]+                           {
                                        R_ECHO(yytext);
                                        
                                        llocp->lines(yyleng);
                                    }
    
    <<EOF>>                         {
                                        yy_pop_state(yyscanner);
                                        R_ERROR("Unclosed comment");
                                        yyterminate();
                                    }
}



                                    /* Allow a triple slash at EOL as a line extender */
\/\/\/\n                            {
                                        R_ECHO(yytext);
                                        
                                        llocp->lines(yyleng); llocp->step();
                                    }



                                    /* Eat short comments */
<INITIAL>"//"                       {
                                        R_ECHO(yytext);
                                        
                                        yy_push_state(SHORT_COMMENT, yyscanner);
                                    }
<INITIAL>^\*                        {
                                        R_ECHO(yytext);
                                        
                                        yy_push_state(SHORT_COMMENT, yyscanner);
                                    }
<SHORT_COMMENT>{
    [^\n]*                          {
                                        R_ECHO(yytext);
                                        
                                        /* eat anything but a newline */
                                    }
    \n                              {
                                        R_ECHO(yytext);
                                        
                                        yy_pop_state(yyscanner);
                                        llocp->lines(1);
                                        return token::TOK_NEWLINE;
                                    }
    <<EOF>>                         {
                                        // one-line comments can be the last thing in the file
                                        yy_pop_state(yyscanner);
                                        llocp->lines(1);
                                        
                                        // unput the newline that the grammar expects will be here
                                        unput('\n');
                                    }
}



                                    /* similarly, lines that start with "!" or "shell" are sh commands */
^\![^\n]*$                          {
                                        R_ECHO(yytext);
                                        
                                        std::string *s = new std::string(yytext);
                                        std::string n = s->substr(1, s->size());

                                        yylval->node = new ExprNode("ado_embedded_code");
                                        yylval->node->addData("value", n);
                                        yylval->node->addData("lang", "shell");
                                        return token::TOK_EMBEDDED_CODE;
                                    }
^shell[^\n]*$                       {
                                        R_ECHO(yytext);
                                        
                                        std::string *s = new std::string(yytext);
                                        std::string n = s->substr(5, s->size());

                                        yylval->node = new ExprNode("ado_embedded_code");
                                        yylval->node->addData("value", n);
                                        yylval->node->addData("type", "shell");
                                        return token::TOK_EMBEDDED_CODE;
                                    }



                                    /* Statement separators; consider more than one in a row to be one */
[\n]                                {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        llocp->lines(yyleng);
                                        return token::TOK_NEWLINE;
                                    }
[;]+                                {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_SEMICOLON;
                                    }

                                    /* ignore whitespace but track column numbers */
{B}+                                {
                                        R_ECHO(yytext);
                                        
                                        llocp->step();
                                    }


<INITIAL>\`\"                       {
                                        R_ECHO(yytext);
                                        
                                        cdquote_buf.clear();
                                        yy_push_state(CDQUOTE, yyscanner);
                                    }
<CDQUOTE>{
                                    /* Allow any type of macro to be nested here */
    \`                              {
                                        R_ECHO(yytext);
                                        
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(LOCAL_MACRO, yyscanner);
                                    }
    \$/({L}|{D})+                   {
                                        R_ECHO(yytext);
                                        
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(GMACRO_ALPHA, yyscanner);
                                    }
    \$\{                            {
                                        R_ECHO(yytext);
                                        
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(GMACRO_BRACE, yyscanner);
                                    }
    
                                    /* Saw the matching close quote - all done */
    \"\'                            {
                                        R_ECHO(yytext);
                                        
                                        std::string *s = new std::string(cdquote_buf);
                                        yylval->node = new ExprNode({"ado_literal", "ado_string_literal"});
                                        yylval->node->addData("value", *s);

                                        yy_pop_state(yyscanner);
                                        return token::TOK_STRING_LITERAL;
                                    }

    \"/[^\']+                       {
                                        R_ECHO(yytext);
                                        
                                        cdquote_buf += std::string(yytext);
                                    }

    \n                              {
                                        // this is an error
                                        R_ECHO(yytext);
                                        llocp->lines(yyleng);
                                        
                                        cdquote_buf.clear();
                                        yy_pop_state(yyscanner);

                                        R_ERROR("Unclosed compound double quote");
                                        yyterminate();
                                    }

    \\\$                            {
                                        R_ECHO(yytext);
                                        
                                        cdquote_buf += '$';
                                    }
    \\\`                            {
                                        R_ECHO(yytext);
                                        
                                        cdquote_buf += '`';
                                    }
    \\n                             {
                                        R_ECHO(yytext);
                                        
                                        cdquote_buf += '\n';
                                    }
    \\t                             {
                                        R_ECHO(yytext);
                                        
                                        cdquote_buf += '\t';
                                    }
    \\r                             {
                                        R_ECHO(yytext);
                                        
                                        cdquote_buf += '\r';
                                    }
    \\b                             {
                                        R_ECHO(yytext);
                                        
                                        cdquote_buf += '\b';
                                    }
    \\f                             {
                                        R_ECHO(yytext);
                                        
                                        cdquote_buf += '\f';
                                    }
    \\.                             {
                                        R_ECHO(yytext);
                                        
                                        cdquote_buf += yytext[1];
                                    }
    \\                              {
                                        R_ECHO(yytext);
                                        
                                        cdquote_buf += '\\';
                                    }

    [^\\\n\`\$\"]+                  {
                                        R_ECHO(yytext);
                                        
                                        cdquote_buf += std::string(yytext);
                                    }

    <<EOF>>                         {
                                        cdquote_buf.clear();
                                        yy_pop_state(yyscanner);

                                        R_ERROR("Unclosed compound double quote");
                                        yyterminate();
                                    }
}

<INITIAL>\"                         {
                                        R_ECHO(yytext);
                                        
                                        string_buf.clear();
                                        yy_push_state(STRING, yyscanner);
                                    }
<STRING>{
                                    /* Allow any type of macro to be nested here */
    \`                              {
                                        R_ECHO(yytext);
                                        
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(LOCAL_MACRO, yyscanner);
                                    }
    \$/({L}|{D})+                   {
                                        R_ECHO(yytext);
                                        
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(GMACRO_ALPHA, yyscanner);
                                    }
    \$\{                            {
                                        R_ECHO(yytext);
                                        
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(GMACRO_BRACE, yyscanner);
                                    }
    
                                    /* Saw the matching close quote - all done */
    \"                              {
                                        R_ECHO(yytext);
                                        
                                        std::string *s = new std::string(string_buf);
                                        yylval->node = new ExprNode({"ado_literal", "ado_string_literal"});
                                        yylval->node->addData("value", *s);

                                        yy_pop_state(yyscanner);
                                        return token::TOK_STRING_LITERAL;
                                    }

    \n                              {
                                        // this is an error
                                        R_ECHO(yytext);
                                        llocp->lines(yyleng);
                                        
                                        string_buf.clear();
                                        yy_pop_state(yyscanner);

                                        R_ERROR("Unclosed string literal");
                                        yyterminate();
                                    }

    \\\"                            {
                                        R_ECHO(yytext);
                                        
                                        string_buf += '"';
                                    }
    \\\`                            {
                                        R_ECHO(yytext);
                                        
                                        string_buf += '`';
                                    }
    \\\$                            {
                                        R_ECHO(yytext);
                                        
                                        string_buf += '$';
                                    }
    \\n                             {
                                        R_ECHO(yytext);
                                        
                                        string_buf += '\n';
                                    }
    \\t                             {
                                        R_ECHO(yytext);
                                        
                                        string_buf += '\t';
                                    }
    \\r                             {
                                        R_ECHO(yytext);
                                        
                                        string_buf += '\r';
                                    }
    \\b                             {
                                        R_ECHO(yytext);
                                        
                                        string_buf += '\b';
                                    }
    \\f                             {
                                        R_ECHO(yytext);
                                        
                                        string_buf += '\f';
                                    }
    \\.                             {
                                        R_ECHO(yytext);
                                        
                                        string_buf += yytext[1];
                                    }
    \\                              {
                                        R_ECHO(yytext);
                                        
                                        string_buf += '\\';
                                    }

    [^\\\n\"\`\$]+                  {
                                        R_ECHO(yytext);
                                        
                                        string_buf += std::string(yytext);
                                    }

    <<EOF>>                         {
                                        string_buf.clear();
                                        yy_pop_state(yyscanner);

                                        R_ERROR("Unclosed string literal");
                                        yyterminate();
                                    }
}



                                   /* datetime literals */
{D}{D}{M}{D}+                      {
                                       R_ECHO(yytext);
                                   
                                       yylval->node = new ExprNode({"ado_literal", "ado_datetime"});

                                       std::string *s = new std::string(yytext);
                                       s->append(" 00:00:00");

                                       yylval->node->addData("value", *s);
                                       return token::TOK_DATE;
                                   }
{D}{D}{M}{D}+[ \t]+{D}{D}:{D}{D}(:{D}{D}(\.{D}+)?)?     {
                                                            R_ECHO(yytext);
                                        
                                                            yylval->node = new ExprNode({"ado_literal", "ado_datetime"});

                                                            std::string *s = new std::string(yytext);
                                                            yylval->node->addData("value", *s);
                                                            return token::TOK_DATETIME;
                                                        }


                                    /* format specifiers */

%-?{D}+\.{D}+(g|f|e|gc|fc)          {
                                        // numeric formats
                                        R_ECHO(yytext);
                                        yylval->node = new ExprNode({"ado_literal", "ado_format_spec"});

                                        std::string *s = new std::string(yytext);
                                        yylval->node->addData("value", *s);
                                        
                                        return token::TOK_NUMBER_FORMAT;
                                    }
%21x|%16H|%16L|%8H|%8L              {
                                        R_ECHO(yytext);
                                        yylval->node = new ExprNode({"ado_literal", "ado_format_spec"});

                                        std::string *s = new std::string(yytext);
                                        yylval->node->addData("value", *s);
                                        
                                        return token::TOK_NUMBER_FORMAT;
                                    }
%[-~]?{D}+s                         {
                                        // string formats
                                        R_ECHO(yytext);
                                        
                                        yylval->node = new ExprNode({"ado_literal", "ado_format_spec"});

                                        std::string *s = new std::string(yytext);
                                        yylval->node->addData("value", *s);
                                        return token::TOK_STRING_FORMAT;
                                    }
%t[Ccdwmqh]{T}*                     {
                                        // datetime formats
                                        R_ECHO(yytext);
                                        yylval->node = new ExprNode({"ado_literal", "ado_format_spec"});

                                        std::string *s = new std::string(yytext);
                                        yylval->node->addData("value", *s);
                                        
                                        return token::TOK_DATETIME_FORMAT;
                                    }



                                    /* Numeric data types */
byte                                {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_BYTE;
                                    }
int                                 {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_INT;
                                    }
long                                {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_LONG;
                                    }
float                               {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_FLOAT;
                                    }
double                              {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_DOUBLE;
                                    }



                                    /* String data types */
str                                 {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_STRING_TYPE_SPEC;
                                    }
str{D}+                             {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_STRING_TYPE_SPEC;
                                    }
strL                                {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_STRING_TYPE_SPEC;
                                    }

                                    /* We need to specially lex this token to get it recognized,
                                     * before we lex numbers */
2sls                                {
                                        R_ECHO(yytext);
                                        
                                        yylval->node = new ExprNode({"ado_literal", "ado_ident"});

                                        yylval->node->addData("value", *(new std::string("tsls")));
                                        return token::TOK_TSLS;
                                    }


                                    /* numeric literals in their various formats */
\.                                  {
                                        R_ECHO(yytext);
                                        
                                        yylval->node = new ExprNode({"ado_literal", "ado_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_PERIOD;
                                    }
0[xX]{H}+                           { /* hex */
                                        R_ECHO(yytext);
                                        
                                        // FIXME need hex floats
                                        yylval->node = new ExprNode({"ado_literal", "ado_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER;
                                    }
0{D}+                               { /* octal */
                                        R_ECHO(yytext);
                                        
                                        // FIXME need octal floats
                                        yylval->node = new ExprNode({"ado_literal", "ado_number"});

                                        // FIXME this should convert value to octal
                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER;
                                    }
{D}+                                { /* decimal integer */
                                        R_ECHO(yytext);
                                        
                                        yylval->node = new ExprNode({"ado_literal", "ado_number"});
                                        
                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER;
                                    }
{D}+\.({D}+)?/[^_A-Za-z_]           { /* decimal float */
                                        R_ECHO(yytext);
                                        
                                        yylval->node = new ExprNode({"ado_literal", "ado_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER;
                                    }
{D}+{E}                             { /* scientific notation */
                                        R_ECHO(yytext);
                                        
                                        yylval->node = new ExprNode({"ado_literal", "ado_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER;
                                    }
{D}*"."{D}+({E})?                   { /* scientific notation with fractions, or numbers like ".0239" */
                                        R_ECHO(yytext);
                                        
                                        yylval->node = new ExprNode({"ado_literal", "ado_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER;
                                    }



                                    /* Other keywords */
using                               {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_USING;
                                    }
if                                  {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_IF;
                                    }
in                                  {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_IN;
                                    }
(1\:1|1\:m|m\:1|m\:m)               {
                                        R_ECHO(yytext);
                                        
                                        yylval->node = new ExprNode({"ado_literal", "ado_string_literal"});
                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_MERGE_SPEC;
                                        }



                                    /* Weight-clause specifiers (this is a hack) */
"["{B}*(a|p|i|f)weight{B}*"="       {
                                        R_ECHO(yytext);
                                        
                                        ExprNode *clause = new ExprNode("ado_weight_clause");
                                        ExprNode *kind = new ExprNode({"ado_literal", "ado_ident"});
                                        std::string *s = new std::string(yytext);

                                        // remove the first and last characters of the string
                                        s->pop_back();
                                        std::string n0 = s->substr(1, s->size());

                                        kind->addData("value", trim(n0));
                                        clause->appendChild("left", kind);

                                        yylval->node = clause;
                                        return token::TOK_WEIGHT_SPEC;
                                    }



                                    /* infix operators and various single-character tokens */
"&"                                 {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_AND_OP;
                                    }
"|"                                 {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_OR_OP;
                                    }
">"                                 {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_GT_OP;
                                    }
"<"                                 {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_LT_OP;
                                    }
">="                                {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_GE_OP;
                                    }
"<="                                {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_LE_OP;
                                    }
"=="                                {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_EQ_OP;
                                    }
"!="                                {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_NE_OP;
                                    }
"~="                                {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_NE_OP;
                                    }
"!"                                 {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_NEG_OP;
                                    }
"~"                                 {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_NEG_OP;
                                    }

\*                                  {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_STAR;
                                    }
\+                                  {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_PLUS;
                                    }
\/                                  {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_SLASH;
                                    }
\-                                  {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_MINUS;
                                    }
\^                                  {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_CARET;
                                    }
=                                   {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_ASSIGN;
                                    }
\[                                  {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_LBRACKET;
                                    }
\]                                  {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_RBRACKET;
                                    }
\(                                  {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_LPAREN;
                                    }
\)                                  {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_RPAREN;
                                    }
\{                                  {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_LBRACE;
                                    }
\}                                  {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_RBRACE;
                                    }
","                                 {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_COMMA;
                                    }
\:                                  {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_COLON;
                                    }

                                    /* Factor variable operators and level-restricted virtual variables */
"c."                                {
                                        R_ECHO(yytext);
                                        
                                        yylval->node = new ExprNode({"ado_expression", "ado_factor_expression", "ado_continuous_expression"});
                                        yylval->node->addData("verb", "c.");

                                        return token::TOK_CONT_OPERATOR;
                                    }
"i."                                {
                                        R_ECHO(yytext);
                                        
                                        yylval->node = new ExprNode({"ado_expression", "ado_factor_expression", "ado_indicator_expression"});
                                        yylval->node->addData("verb", "i.");

                                        return token::TOK_IND_OPERATOR;
                                    }

i?"bn."                             {
                                        R_ECHO(yytext);
                                        
                                        yylval->node = new ExprNode({"ado_expression", "ado_factor_expression", "ado_baseline_expression"});
                                        yylval->node->addData("verb", "ib.");
                                        yylval->node->addData("level", "n");

                                        return token::TOK_BASE_OPERATOR;
                                    }
i?"b(freq)."                        {
                                        R_ECHO(yytext);
                                        
                                        yylval->node = new ExprNode({"ado_expression", "ado_factor_expression", "ado_baseline_expression"});
                                        yylval->node->addData("verb", "ib.");
                                        yylval->node->addData("level", "freq");

                                        return token::TOK_BASE_OPERATOR;
                                    }
i?"b(last)."                        {
                                        R_ECHO(yytext);
                                        
                                        yylval->node = new ExprNode({"ado_expression", "ado_factor_expression", "ado_baseline_expression"});
                                        yylval->node->addData("verb", "ib.");
                                        yylval->node->addData("level", "last");

                                        return token::TOK_BASE_OPERATOR;
                                    }
i?"b(first)."                       {
                                        R_ECHO(yytext);
                                        
                                        yylval->node = new ExprNode({"ado_expression", "ado_factor_expression", "ado_baseline_expression"});
                                        yylval->node->addData("verb", "ib.");
                                        yylval->node->addData("level", "first");

                                        return token::TOK_BASE_OPERATOR;
                                    }
i?"b"{D}+"."                        {
                                        R_ECHO(yytext);
                                        
                                        std::string *s = new std::string(yytext);

                                        yylval->node = new ExprNode({"ado_expression", "ado_factor_expression", "ado_baseline_expression"});
                                        yylval->node->addData("verb", "ib.");

                                        if(s->at(0) == 'i')
                                          yylval->node->addData("level", s->substr(2, s->length() - 1));
                                        else
                                          yylval->node->addData("level", s->substr(1, s->length() - 1));

                                        return token::TOK_BASE_OPERATOR;
                                    }
i?"b(#"{D}+")."                     {
                                        R_ECHO(yytext);
                                        
                                        std::string *s = new std::string(yytext);

                                        yylval->node = new ExprNode({"ado_expression", "ado_factor_expression", "ado_baseline_expression"});
                                        yylval->node->addData("verb", "ib.");

                                        if(s->at(0) == 'i')
                                          yylval->node->addData("level", s->substr(4, s->length() - 2));
                                        else
                                          yylval->node->addData("level", s->substr(3, s->length() - 2));

                                        return token::TOK_BASE_OPERATOR;
                                    }

i?{D}+"."                          {
                                        R_ECHO(yytext);
                                        
                                        std::string *s = new std::string(yytext);

                                        yylval->node = new ExprNode({"ado_expression", "ado_factor_expression", "ado_indicator_expression"});
                                        yylval->node->addData("verb", "i.");
                                        yylval->node->addData("level", s->substr(1, s->length() - 1));

                                        return token::TOK_IND_OPERATOR;
                                    }
"i("{D}+(\ +{D}+)*")."              {
                                        R_ECHO(yytext);
                                        
                                        std::string *s = new std::string(yytext);
                                        std::vector<std::string> x = split(s->substr(2, s->length() - 2), ' ');

                                        yylval->node = new ExprNode({"ado_expression", "ado_factor_expression", "ado_indicator_expression"});
                                        yylval->node->addData("verb", "i.");

                                        for(auto elem : x)
                                        {
                                            if(!elem.empty())
                                                yylval->node->addData("level" + elem, elem); // hacky, but oh well
                                        }

                                        return token::TOK_IND_OPERATOR;
                                    }
"i("\ *{D}+\ *\/{D}+\ *")."         {
                                        R_ECHO(yytext);
                                        
                                        std::string *s = new std::string(yytext);
                                        std::vector<std::string> x = split(s->substr(2, s->length() -2), '/');
                                        yylval->node = new ExprNode({"ado_expression", "ado_factor_expression", "ado_indicator_expression"});
                                        yylval->node->addData("verb", "i.");

                                        yylval->node->addData("levelstart", trim(x[0]));
                                        yylval->node->addData("levelend", trim(x[1]));

                                        return token::TOK_IND_OPERATOR;
                                    }

i?"o"{D}+"."                        {
                                        R_ECHO(yytext);
                                        
                                        std::string *s = new std::string(yytext);

                                        yylval->node = new ExprNode({"ado_expression", "ado_factor_expression", "ado_omit_expression"});
                                        yylval->node->addData("verb", "o.");

                                        if(s->at(0) == 'i')
                                          yylval->node->addData("level", s->substr(2, s->length() - 1));
                                        else
                                          yylval->node->addData("level", s->substr(1, s->length() - 1));

                                        return token::TOK_OMIT_OPERATOR;
                                    }
i?"o("{D}+(\ +{D}+)*")."            {
                                        R_ECHO(yytext);
                                        
                                        std::string *s = new std::string(yytext);
                                        std::vector<std::string> x;

                                        yylval->node = new ExprNode({"ado_expression", "ado_factor_expression", "ado_omit_expression"});
                                        yylval->node->addData("verb", "o.");

                                        if(s->at(0) == 'i')
                                            x = split(s->substr(3, s->length() -2), ' ');
                                        else
                                            x = split(s->substr(2, s->length() -2), ' ');

                                        for(auto elem : x)
                                        {
                                            if(!elem.empty())
                                                yylval->node->addData("level" + elem, elem); // hacky, but oh well
                                        }

                                        return token::TOK_IND_OPERATOR;
                                    }
i?"o("\ *{D}+\ *\/{D}+\ *")."       {
                                        R_ECHO(yytext);
                                        
                                        std::string *s = new std::string(yytext);
                                        std::vector<std::string> x;

                                        yylval->node = new ExprNode({"ado_expression", "ado_factor_expression", "ado_omit_expression"});
                                        yylval->node->addData("verb", "o.");

                                        if(s->at(0) == 'i')
                                            x = split(s->substr(3, s->length() -2), '/');
                                        else
                                            x = split(s->substr(2, s->length() -2), '/');

                                        yylval->node->addData("levelstart", trim(x[0]));
                                        yylval->node->addData("levelend", trim(x[1]));

                                        return token::TOK_IND_OPERATOR;
                                    }

"##"                                {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_FACT_CROSS;
                                    }
"#"                                 {
                                        R_ECHO(yytext);
                                        
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_CROSS;
                                    }



                                    /* command verbs that have to be hardcoded into the grammar */
capture                             {
                                        R_ECHO(yytext);
                                        
                                        ExprNode *verb = new ExprNode({"ado_literal", "ado_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = verb;
                                        return token::TOK_CAPTURE;
                                    }
cap                                 {
                                        R_ECHO(yytext);
                                        
                                        ExprNode *verb = new ExprNode({"ado_literal", "ado_ident"});
                                        verb->addData("value", "capture");

                                        yylval->node = verb;
                                        return token::TOK_CAPTURE;
                                    }
quietly                             {
                                        R_ECHO(yytext);
                                        
                                        ExprNode *verb = new ExprNode({"ado_literal", "ado_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = verb;
                                        return token::TOK_QUIETLY;
                                    }
qui                                 {
                                        R_ECHO(yytext);
                                        
                                        ExprNode *verb = new ExprNode({"ado_literal", "ado_ident"});
                                        verb->addData("value", "quietly");

                                        yylval->node = verb;
                                        return token::TOK_QUIETLY;
                                    }
noisily                             {
                                        R_ECHO(yytext);
                                        
                                        ExprNode *verb = new ExprNode({"ado_literal", "ado_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = verb;
                                        return token::TOK_NOISILY;
                                    }
                                    
                                    /* Non-prefix special commands */
by                                  {
                                        R_ECHO(yytext);
                                        
                                        ExprNode *verb = new ExprNode({"ado_literal", "ado_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = verb;
                                        return token::TOK_BY;
                                    }
bysort                              {
                                        R_ECHO(yytext);
                                        
                                        ExprNode *verb = new ExprNode({"ado_literal", "ado_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = verb;
                                        return token::TOK_BYSORT;
                                    }
xi                                  {
                                        R_ECHO(yytext);
                                        
                                        ExprNode *verb = new ExprNode({"ado_literal", "ado_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = verb;
                                        return token::TOK_XI;
                                    }

                                    /* Commands which have to be lexed and parsed differently because they
                                     * have idiosyncratic syntax */
merge                               {
                                        R_ECHO(yytext);
                                        
                                        ExprNode *verb = new ExprNode({"ado_literal", "ado_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = verb;
                                        return token::TOK_MERGE;
                                    }
collapse                            {
                                        R_ECHO(yytext);
                                        
                                        ExprNode *verb = new ExprNode({"ado_literal", "ado_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = verb;
                                        return token::TOK_COLLAPSE;
                                    }
recode                              {
                                        R_ECHO(yytext);
                                        
                                        ExprNode *verb = new ExprNode({"ado_literal", "ado_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = verb;
                                        return token::TOK_RECODE;
                                    }
ivregress                           {
                                        R_ECHO(yytext);
                                        
                                        ExprNode *verb = new ExprNode({"ado_literal", "ado_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = verb;
                                        return token::TOK_IVREGRESS;
                                    }
gsort                               {
                                        R_ECHO(yytext);
                                        
                                        ExprNode *verb = new ExprNode({"ado_literal", "ado_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = verb;
                                        return token::TOK_GSORT;
                                    }
lrtest                              {
                                        R_ECHO(yytext);
                                        
                                        ExprNode *verb = new ExprNode({"ado_literal", "ado_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = verb;
                                        return token::TOK_LRTEST;
                                    }
anova                               {
                                        R_ECHO(yytext);
                                        
                                        ExprNode *verb = new ExprNode({"ado_literal", "ado_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = verb;
                                        return token::TOK_ANOVA;
                                    }



                                    /* all non-keyword identifiers */
[_A-Za-z][A-Za-z0-9_]*              {
                                        R_ECHO(yytext);
                                        
                                        yylval->node = new ExprNode({"ado_literal", "ado_ident"});
                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_IDENT;
                                    }

.                                   {
                                        R_ECHO(yytext);
                                        R_ERROR("Illegal character");
                                        yyterminate();
                                    }

<<EOF>>                             { return token::TOK_END; }

%%

void
ado_yy_fatal_error(const char *msg)
{
    Rcpp::List cond;
    Rcpp::CharacterVector cls;

    cond["message"] = std::string(msg);
    cond["call"] = R_NilValue;
    
    cls = Rcpp::CharacterVector::create("error", "condition");
    
    cond.attr("class") = cls;
    Rcpp::Function stopper("stop");
    stopper(cond);
}

std::vector<std::string> &
split(const std::string &s, char delim, std::vector<std::string> &elems) {
    std::stringstream ss(s);
    std::string item;
    while (std::getline(ss, item, delim)) {
        elems.push_back(item);
    }
    return elems;
}

std::vector<std::string>
split(const std::string &s, char delim) {
    std::vector<std::string> elems;
    split(s, delim, elems);
    return elems;
}

std::string
trim(const std::string& str, const std::string& what)
{
    size_t start = str.find_first_not_of(what);
    size_t end = str.find_last_not_of(what);
    size_t len = end - start + 1;

    if (start == std::string::npos)
        return "";

    return str.substr(start, len);
}

