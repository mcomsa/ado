%skeleton "lalr1.cc" /* -*- C++ -*- */
%require "3.0.2"

%defines
%define parser_class_name { AdoParser }
%define parse.trace
%define parse.error verbose
%define api.token.prefix {TOK_}
%define api.pure

%pure-parser
%locations

%code requires
{
#include "Ado.hpp"
class ParseDriver;
typedef void* yyscan_t;

#define YY_DECL int yylex(yy::AdoParser::semantic_type* yylval_param, \
                          yy::AdoParser::location_type* llocp,        \
                          ParseDriver& driver, yyscan_t yyscanner)      

#define R_ACTION(node) driver.wrap_cmd_action(node);
#define RETURN_AST(node) driver.set_ast(node);
}

%param { ParseDriver& driver }
%param { yyscan_t yyscanner }

%union
{
    std::string   *str;
    ExprNode      *node;
}

%code
{
#include <string>
#include <Rcpp.h>
#include "ParseDriver.hpp"

YY_DECL;

void
yy::AdoParser::error(const location_type& l, const std::string& m)
{
    driver.error(l.begin.line, l.begin.column, m);
}

}

/* Operator  precedence */
%precedence RELATIONAL
%precedence "+" "-"
%precedence EXPONENT
%precedence "("

/* EOF and command separators */
%token END 0 "end of file"

%token <str>
    NEWLINE
    SEMICOLON       ";"
;

/* Operators or symbols whose values don't need to be passed up to the next layer */
%token
    LPAREN          "("
    RPAREN          ")"
    COMMA           ","
    LBRACE          "{"
    RBRACE          "}"
    LBRACKET        "["
    RBRACKET        "]"
    COLON           ":"
    ASSIGN          "="
;

/* Operators or tokens whose values need to be passed up to the next layer */
%token <str>
    PLUS            "+"
    LT_OP           "<"
    GT_OP           ">"
    NEG_OP          "!"
    STAR            "*"
    SLASH           "/"
    MINUS           "-"
    CARET           "^"
    GE_OP           ">="
    LE_OP           "<="
    EQ_OP           "=="
    NE_OP           "!="
    OR_OP           "|"
    AND_OP          "&"
    FACT_CROSS      "##"
    CROSS           "#"
;

                /* Literals of various fundamental types */
%token <node>   NUMBER IDENT STRING_LITERAL DATE DATETIME
%token <node>
    PERIOD          "."
;

                /* Type specifiers */
%token <str>    BYTE INT LONG FLOAT DOUBLE STRING_TYPE_SPEC

                /* Formats */
%token <node>   STRING_FORMAT DATETIME_FORMAT NUMBER_FORMAT
%type  <node>   format_spec

                /* Commands with unusual enough syntax they have to be parsed separately */
%token <node>   EMBEDDED_CODE
%token <node>   BY XI BYSORT
%token <node>   QUIETLY CAPTURE NOISILY /* Prefix commands that can be used without a colon */
%token <node>   MERGE COLLAPSE IVREGRESS RECODE GSORT LRTEST ANOVA
%token <node>   TSLS /* this is an awful hack */

                /* Command components and keywords */
%token          USING IF IN
%token <node>   WEIGHT_SPEC
%token <node>   MERGE_SPEC

                /* Factor variable operators */
%token <node>   CONT_OPERATOR IND_OPERATOR BASE_OPERATOR OMIT_OPERATOR

                /* Loops
                 * unlike other tokens, these tokens are only recognized in
                 * certain lexer states that indicate we're parsing a loop */
%token <node>   FOREACH FORVALUES
%type  <node>   foreach_cmd forvalues_cmd
%token          LOCAL GLOBAL VARLIST NEWLIST NUMLIST TO OF

                /* Nonterminal token types */
%type <node>    error cmd_sep
%type <node>    translation_unit external_statement compound_cmd cmds modifier_cmd_list cmd
%type <node>    modifier_cmd nonmodifier_cmd long_modifier_cmd if_cmd

%type <node>    unary_factor_operator

%type <str>     unary_operator power_operator equality_operator
%type <str>     multiplication_operator additive_operator relational_operator logical_operator
%type <str>     cross_operator type_operator

%type <node>    if_clause in_clause weight_clause using_clause

%type <node>    expression
%type <node>    primary_expression postfix_expression power_expression literal_expression
%type <node>    unary_expression multiplication_expression additive_expression
%type <node>    relational_expression equality_expression logical_expression
%type <node>    cross_expression unary_factor_expression number_or_missing

%type <node>    option options option_ident
%type <node>    option_list argument_expression_list expression_list

                /* Non-terminals for the syntax of special commands */
%type <node>    anova_term_list collapse_list collapse_spec gsort_var
%type <node>    gsort_varlist modelspec modelspec_list numlist collapse_spec_base
%type <node>    recode_rule recode_rule_list varlist collapse_spec_base_list
%type <node>    anova_nest_expression anova_error_expression

%destructor { }                 translation_unit
%destructor { delete $$; }      <str>
%destructor { delete $$; }      <node>

%start translation_unit
%%

/*
 *************************************************
 * The start symbol, a "command" and escaping to R
 *************************************************
 */

translation_unit:
      external_statement
    {
        ExprNode *node = new ExprNode("ado_compound_cmd");
        node->appendChild($1);
        RETURN_AST(node);

        if( !($1->isDummy()) )
        {
            R_ACTION(node);
        }

        $$ = node;
    }
    | translation_unit external_statement
    {
        $1->appendChild($2);

        if( !($2->isDummy()) )
        {
            ExprNode *node = new ExprNode("ado_compound_cmd");
            node->appendChild($2);

            // FIXME? is this a memory leak?
            RETURN_AST(node);
            R_ACTION(node);
        } else
        {
            RETURN_AST($1);
        }

        $$ = $1;
    }
    | translation_unit error
    {
        $2; // shut up, bison...

        // we shouldn't need to use set_ast here, because the earlier
        // production that created the translation_unit will have done
        // so already (unlike the one-statement error production below)
        $$ = $1;
    }
    | error
    {
        $1; // shut up, bison...
        
        ExprNode *node = new ExprNode("ado_compound_cmd");
        
        RETURN_AST(node);
        $$ = node;
    }
    ;

external_statement:
      cmd
    | compound_cmd
    | if_cmd
    | foreach_cmd
    | forvalues_cmd
    ;

/* The things between the braces are not literally string literals,
 * even though they look like it by the time the parser sees them. The
 * lexer accumulates the text of the loop body and returns it to the parser
 * as a string even though it's not enclosed in double quotes in the original
 * source code. The function that executes this command invokes a new parser
 * instance on the text each time around the loop. If things get any more
 * complicated than this, we'll have to refactor into a two-pass parse with
 * a preprocessor for loops and macros on the first stage.
 * (Which might be a good idea anyway...)
 */
foreach_cmd:
      FOREACH IDENT foreach_sep varlist         "{" STRING_LITERAL "}"
    {
        $1->appendChild("macro_name", $2);
        $1->appendChild("text", $6);
        $1->appendChild("varlist", $4);

        $$ = $1;
    }
    | FOREACH IDENT foreach_sep numlist         "{" STRING_LITERAL "}"
    {
        $1->appendChild("macro_name", $2);
        $1->appendChild("text", $6);
        $1->appendChild("numlist", $4);

        $$ = $1;
    }
    | FOREACH IDENT foreach_sep LOCAL IDENT     "{" STRING_LITERAL "}"
    {
        $1->appendChild("macro_name", $2);
        $1->appendChild("text", $7);
        $1->appendChild("local_macro_source", $5);

        $$ = $1;
    }
    | FOREACH IDENT foreach_sep GLOBAL IDENT    "{" STRING_LITERAL "}"
    {
        $1->appendChild("macro_name", $2);
        $1->appendChild("text", $7);
        $1->appendChild("global_macro_source", $5);

        $$ = $1;
    }
    | FOREACH IDENT foreach_sep VARLIST varlist "{" STRING_LITERAL "}"
    {
        $1->appendChild("macro_name", $2);
        $1->appendChild("text", $7);
        $1->appendChild("varlist", $5);

        $$ = $1;
    }
    | FOREACH IDENT foreach_sep NEWLIST varlist "{" STRING_LITERAL "}"
    {
        $1->appendChild("macro_name", $2);
        $1->appendChild("text", $7);
        $1->appendChild("varlist", $5);

        $$ = $1;
    }
    | FOREACH IDENT foreach_sep NUMLIST numlist "{" STRING_LITERAL "}"
    {
        $1->appendChild("macro_name", $2);
        $1->appendChild("text", $7);
        $1->appendChild("numlist", $5);

        $$ = $1;
    }
    ;

forvalues_cmd:
      FORVALUES IDENT "=" NUMBER "(" NUMBER ")" NUMBER "{" STRING_LITERAL "}"
    {
        $1->appendChild("macro_name", $2);
        $1->appendChild("text", $10);

        $1->appendChild("upper", $8);
        $1->appendChild("lower", $4);
        $1->appendChild("increment", $6);

        $$ = $1;
    }
    | FORVALUES IDENT "=" NUMBER "/" NUMBER            "{" STRING_LITERAL "}"
    {
        $5; // shut up, bison...
        
        $1->appendChild("macro_name", $2);
        $1->appendChild("text", $8);

        $1->appendChild("upper", $6);
        $1->appendChild("lower", $4);
        // if "increment" and "increment_t" are both missing, assume increment = 1

        $$ = $1;
    }
    | FORVALUES IDENT "=" NUMBER NUMBER ":" NUMBER     "{" STRING_LITERAL "}"
    {
        $1->appendChild("macro_name", $2);
        $1->appendChild("text", $9);

        $1->appendChild("upper", $7);
        $1->appendChild("lower", $4);
        $1->appendChild("increment_t", $5);

        $$ = $1;
    }
    | FORVALUES IDENT "=" NUMBER NUMBER TO NUMBER      "{" STRING_LITERAL "}"
    {
        $1->appendChild("macro_name", $2);
        $1->appendChild("text", $9);

        $1->appendChild("upper", $7);
        $1->appendChild("lower", $4);
        $1->appendChild("increment_t", $5);

        $$ = $1;
    }
    ;

foreach_sep:
      IN
    | OF
    ;

if_cmd:
    IF expression compound_cmd
    {
        ExprNode *node = new ExprNode("ado_if_cmd");
        node->appendChild("expression", $2);
        node->appendChild("compound_cmd", $3);

        $$ = node;
    }
    ;

compound_cmd:
    "{" cmds "}"
    {
        $$ = $2;
    }
    ;

cmds:
      cmd
    {
        ExprNode *node = new ExprNode("ado_compound_cmd");

        node->appendChild($1);

        $$ = node;
    }
    | compound_cmd
    {
        $$ = $1;
    }
    | cmds cmd
    {
        $1->appendChild($2);

        $$ = $1;
    }
    | cmds compound_cmd
    {
        $1->appendChild($2);

        $$ = $1;
    }
    ;

cmd:
      cmd_sep
    | EMBEDDED_CODE /* R or shell */

    | nonmodifier_cmd cmd_sep
    {
        $2; // suppressing a stupid bison warning

        $$ = $1;
    }
    | long_modifier_cmd ":" modifier_cmd_list compound_cmd cmd_sep
    {
        $3->prependChild($1);
        $3->appendChild("main_cmd", $4);

        $5; // suppressing a stupid bison warning

        $$ = $3;
    }
    | long_modifier_cmd ":" modifier_cmd_list nonmodifier_cmd cmd_sep
    {
        $3->prependChild($1);
        $3->appendChild("main_cmd", $4);

        $5; // suppressing a stupid bison warning

        $$ = $3;
    }
    | long_modifier_cmd ":" nonmodifier_cmd cmd_sep
    {
        ExprNode *node = new ExprNode("ado_modifier_cmd_list");

        $4; // suppressing a stupid bison warning

        node->appendChild($1);
        node->appendChild("main_cmd", $3);

        $$ = node;
    }
    | modifier_cmd_list nonmodifier_cmd cmd_sep
    {
        $3; // suppressing a stupid bison warning

        $1->appendChild("main_cmd", $2);

        $$ = $1;
    }
    | modifier_cmd_list ":" nonmodifier_cmd cmd_sep
    {
        $4; // suppressing a stupid bison warning

        $1->appendChild("main_cmd", $3);

        $$ = $1;
    }
    | modifier_cmd_list compound_cmd cmd_sep
    {
        $3; // suppressing a stupid bison warning

        $1->appendChild("main_cmd", $2);

        $$ = $1;
    }
    | modifier_cmd_list ":" compound_cmd cmd_sep
    {
        $4; // suppressing a stupid bison warning

        $1->appendChild("main_cmd", $3);

        $$ = $1;
    }
    | modifier_cmd_list long_modifier_cmd ":" nonmodifier_cmd cmd_sep
    {
        $5; // suppressing a stupid bison warning

        $1->appendChild($2);
        $1->appendChild("main_cmd", $4);

        $$ = $1;
    }
    | modifier_cmd_list long_modifier_cmd ":" compound_cmd cmd_sep
    {
        $5; // suppressing a stupid bison warning

        $1->appendChild($2);
        $1->appendChild("main_cmd", $4);

        $$ = $1;
    }
    | modifier_cmd_list long_modifier_cmd ":" modifier_cmd_list nonmodifier_cmd cmd_sep
    {
        $6; // suppressing a stupid bison warning

        $1->appendChild($2);
        $1->appendChild($4);
        $1->appendChild("main_cmd", $5);

        $$ = $1;
    }
    | modifier_cmd_list long_modifier_cmd ":" modifier_cmd_list compound_cmd cmd_sep
    {
        $6; // suppressing a stupid bison warning

        $1->appendChild($2);
        $1->appendChild($4);
        $1->appendChild("main_cmd", $5);

        $$ = $1;
    }
    ;

cmd_sep:
      NEWLINE
    {
        $1; // suppressing a stupid bison warning

        $$ = new ExprNode();
    }
    | ";"
    {
        $1; // suppressing a stupid bison warning

        $$ = new ExprNode();
    }
    ;

modifier_cmd:
      CAPTURE
    {
        ExprNode *node = new ExprNode({"ado_cmd", "ado_modifier_cmd"});
        node->appendChild("verb", $1);

        $$ = node;
    }
    | QUIETLY
    {
        ExprNode *node = new ExprNode({"ado_cmd", "ado_modifier_cmd"});
        node->appendChild("verb", $1);

        $$ = node;
    }
    | NOISILY
    {
        ExprNode *node = new ExprNode({"ado_cmd", "ado_modifier_cmd"});
        node->appendChild("verb", $1);

        $$ = node;
    }
    ;

long_modifier_cmd:
      BYSORT expression_list option_list
    {
        ExprNode *node = new ExprNode({"ado_cmd", "ado_general_cmd"});
        node->appendChild("verb", $1);

        node->appendChild("expression_list", $2);

        if($3->nChildren() > 0)
          node->appendChild("option_list", $3);

        $$ = node;
    }
    | BY expression_list option_list
    {
        ExprNode *node = new ExprNode({"ado_cmd", "ado_general_cmd"});
        node->appendChild("verb", $1);

        node->appendChild("expression_list", $2);

        if($3->nChildren() > 0)
          node->appendChild("option_list", $3);

        $$ = node;
    }
    | XI option_list
    {
        ExprNode *node = new ExprNode({"ado_cmd", "ado_general_cmd"});
        node->appendChild("verb", $1);

        if($2->nChildren() > 0)
          node->appendChild("option_list", $2);

        $$ = node;
    }
    ;

modifier_cmd_list:
      modifier_cmd
    {
        ExprNode *node = new ExprNode("ado_modifier_cmd_list");
        node->appendChild($1);
        $$ = node;
    }
    | modifier_cmd_list modifier_cmd
    {
        $1->appendChild($2);
        $$ = $1;
    }
    ;

nonmodifier_cmd:
      IDENT expression_list if_clause in_clause weight_clause using_clause option_list
    {
        ExprNode *node = new ExprNode({"ado_cmd", "ado_general_cmd"});
        node->appendChild("verb", $1);
        node->appendChild("expression_list", $2);

        if($3->nChildren() > 0)
            node->appendChild("if_clause", $3);

        if($4->nChildren() > 0)
            node->appendChild("in_clause", $4);

        if($5->nChildren() > 0)
            node->appendChild("weight_clause", $5);

        if($6->nChildren() > 0)
            node->appendChild("using_clause", $6);

        if($7->nChildren() > 0)
            node->appendChild("option_list", $7);

        $$ = node;
    }
    | IDENT if_clause in_clause weight_clause using_clause option_list
    {
        ExprNode *node = new ExprNode({"ado_cmd", "ado_general_cmd"});
        node->appendChild("verb", $1);

        if($2->nChildren() > 0)
            node->appendChild("if_clause", $2);

        if($3->nChildren() > 0)
            node->appendChild("in_clause", $3);

        if($4->nChildren() > 0)
            node->appendChild("weight_clause", $4);

        if($5->nChildren() > 0)
            node->appendChild("using_clause", $5);

        if($6->nChildren() > 0)
            node->appendChild("option_list", $6);

        $$ = node;
    }

    /* Commands with unusual enough syntax that they have to be parsed
     * separately. In some abstract sense, there shouldn't be so many
     * of these, but with Stata defined the way it is, there's not much
     * we can do about it. */
    | MERGE MERGE_SPEC expression_list using_clause option_list
    {
        ExprNode *node = new ExprNode({"ado_cmd", "ado_general_cmd"});
        node->appendChild("verb", $1);

        if($3->nChildren() > 0)
            node->appendChild("expression_list", $3);

        if($4->nChildren() > 0)
            node->appendChild("using_clause", $4);

        // we're going to make the merge_spec an option
        ExprNode *opt = new ExprNode("ado_option");
        ExprNode *name = new ExprNode({"ado_literal", "ado_ident"});
        name->addData("value", *(new std::string("merge_spec")));
        opt->appendChild("name", name);
        
        ExprNode *arglist = new ExprNode("ado_argument_expression_list");
        ExprNode *explist = new ExprNode("ado_expression_list");
        explist->appendChild($2);
        arglist->appendChild(explist);
        opt->appendChild("args", arglist);
        
        $5->appendChild(opt);
        node->appendChild("option_list", $5);

        $$ = node;
    }
    | XI expression_list option_list /* only necessary because this is a keyword */
    {
        ExprNode *node = new ExprNode({"ado_cmd", "ado_general_cmd"});
        node->appendChild("verb", $1);

        node->appendChild("expression_list", $2);
        
        if($3->nChildren() > 0)
            node->appendChild("option_list", $3);

        $$ = node;
    }
    | IVREGRESS TSLS varlist "(" varlist "=" varlist ")" if_clause in_clause weight_clause option_list
    {
        ExprNode *node = new ExprNode({"ado_cmd", "ado_general_cmd"});
        node->appendChild("verb", $1);

        $3->prependChild($2);
        node->appendChild("expression_list", $3);

        if($9->nChildren() > 0)
            node->appendChild("if_clause", $9);

        if($10->nChildren() > 0)
            node->appendChild("in_clause", $10);

        if($11->nChildren() > 0)
            node->appendChild("weight_clause", $11);

        // We're going to make the other two varlists into options
        ExprNode *endogenous_opt = new ExprNode("ado_option");
        ExprNode *endogenous_name = new ExprNode({"ado_literal", "ado_ident"});
        endogenous_name->addData("value", *(new std::string("endogenous_vars")));
        endogenous_opt->appendChild("name", endogenous_name);
        
        ExprNode *endogenous_args = new ExprNode("ado_argument_expression_list");
        endogenous_args->appendChild($5);
        endogenous_opt->appendChild("args", endogenous_args);

        ExprNode *instrumental_opt = new ExprNode("ado_option");
        ExprNode *instrumental_name = new ExprNode({"ado_literal", "ado_ident"});
        instrumental_name->addData("value", *(new std::string("instrumental_vars")));
        instrumental_opt->appendChild("name", instrumental_name);
        
        ExprNode *instrumental_args = new ExprNode("ado_argument_expression_list");
        instrumental_args->appendChild($7);
        instrumental_opt->appendChild("args", instrumental_args);
        
        $11->appendChild(endogenous_opt);
        $11->appendChild(instrumental_opt);
        node->appendChild("option_list", $12);

        $$ = node;
    }
    | GSORT gsort_varlist option_list
    {
        ExprNode *node = new ExprNode({"ado_cmd", "ado_general_cmd"});
        node->appendChild("verb", $1);

        node->appendChild("expression_list", $2);

        if($3->nChildren() > 0)
            node->appendChild("option_list", $3);

        $$ = node;
    }
    | COLLAPSE collapse_spec_base_list if_clause in_clause weight_clause option_list
    {
        ExprNode *cmd = new ExprNode({"ado_cmd", "ado_general_cmd"});
        cmd->appendChild("verb", $1);

        /* the components which are correct as-is */
        if($3->nChildren() > 0)
            cmd->appendChild("if_clause", $3);

        if($4->nChildren() > 0)
            cmd->appendChild("in_clause", $4);

        if($5->nChildren() > 0)
            cmd->appendChild("weight_clause", $5);

        if($6->nChildren() > 0)
            cmd->appendChild("option_list", $6);

        /* the expression list we need to wrap in a function call */
        ExprNode *node = new ExprNode({"ado_expression", "ado_postfix_expression"});
        node->addData("verb", *(new std::string("()")));
        
        // the "left" child
        ExprNode *left = new ExprNode({"ado_literal", "ado_ident"});
        left->addData("value", *(new std::string("collapse_stat")));
        node->appendChild("left", left);
        
        // the "right" child
        ExprNode *mean = new ExprNode({"ado_literal", "ado_ident"});
        mean->addData("value", *(new std::string("mean")));

        ExprNode *explist = new ExprNode("ado_expression_list");
        ExprNode *arglist = new ExprNode("ado_argument_expression_list");
        
        explist->appendChild(mean); // stat goes first
        arglist->appendChild(explist);
        arglist->appendChild($2); // variable names or assignments follow
        
        node->appendChild("right", arglist);
        cmd->appendChild("expression_list", node);
        
        $$ = cmd;
    }
    | COLLAPSE collapse_list if_clause in_clause weight_clause option_list
    {
        ExprNode *node = new ExprNode({"ado_cmd", "ado_general_cmd"});
        node->appendChild("verb", $1);

        node->appendChild("expression_list", $2);

        if($3->nChildren() > 0)
            node->appendChild("if_clause", $3);

        if($4->nChildren() > 0)
            node->appendChild("in_clause", $4);

        if($5->nChildren() > 0)
            node->appendChild("weight_clause", $5);

        if($6->nChildren() > 0)
            node->appendChild("option_list", $6);

        $$ = node;
    }
    | LRTEST modelspec_list option_list
    {
        ExprNode *node = new ExprNode({"ado_cmd", "ado_general_cmd"});
        node->appendChild("verb", $1);

        node->appendChild("expression_list", $2);

        if($3->nChildren() > 0)
            node->appendChild("option_list", $3);

        $$ = node;
    }
    | ANOVA IDENT anova_term_list if_clause in_clause weight_clause option_list
    {
        ExprNode *node = new ExprNode({"ado_cmd", "ado_general_cmd"});
        node->appendChild("verb", $1);

        $3->prependChild($2);
        node->appendChild("expression_list", $3);
        
        if($4->nChildren() > 0)
            node->appendChild("if_clause", $4);

        if($5->nChildren() > 0)
            node->appendChild("in_clause", $5);

        if($6->nChildren() > 0)
            node->appendChild("weight_clause", $6);

        if($7->nChildren() > 0)
            node->appendChild("option_list", $7);
        
        $$ = node;
    }
    | RECODE recode_rule_list if_clause in_clause option_list
    {
        ExprNode *node = new ExprNode({"ado_cmd", "ado_general_cmd"});
        node->appendChild("verb", $1);

        node->appendChild("expression_list", $2);

        if($3->nChildren() > 0)
            node->appendChild("if_clause", $3);

        if($4->nChildren() > 0)
            node->appendChild("in_clause", $4);

        if($5->nChildren() > 0)
            node->appendChild("option_list", $5);
        
        $$ = node;
    }
    ;

/* Helper constructs for multiple special commands */
varlist:
      IDENT
    {
        ExprNode *node = new ExprNode("ado_expression_list");
        node->appendChild($1);
        $$ = node;
    }
    | varlist IDENT
    {
        $1->appendChild($2);
        $$ = $1;
    }
    ;

number_or_missing:
      NUMBER
    | PERIOD
    ;

numlist:
      number_or_missing
    {
        ExprNode *node = new ExprNode("ado_expression_list");
        node->appendChild($1);
        $$ = node;
    }
    | numlist number_or_missing
    {
        $1->appendChild($2);
        $$ = $1;
    }
    ;

/* Helper constructs for collapse */
collapse_spec_base:
      IDENT
    | IDENT "=" IDENT
    {
        // this would be an assignment expression as usual, except that
        // for every single other command than this one, assignment expressions
        // shouldn't be allowed in function argument lists. they're not allowed here
        // syntactically either, and it'd be an even uglier hack to allow them everywhere
        // just for this internal representation.
        ExprNode *node = new ExprNode({"ado_expression", "ado_postfix_expression"});
        node->addData("verb", *(new std::string("()")));
        
        // the "left" child
        ExprNode *left = new ExprNode({"ado_literal", "ado_ident"});
        left->addData("value", *(new std::string("collapse_newvar")));
        node->appendChild("left", left);

        // the "right" child
        ExprNode *arglist = new ExprNode("ado_argument_expression_list");
        ExprNode *explist = new ExprNode("ado_expression_list");
        explist->appendChild($1);
        explist->appendChild($3);
        arglist->appendChild(explist);
        
        node->appendChild("right", arglist);
        $$ = node;
    }
    ;

collapse_spec_base_list:
      collapse_spec_base
    {
        ExprNode *node = new ExprNode("ado_expression_list");
        node->appendChild($1);
        $$ = node;
    }
    | collapse_spec_base_list collapse_spec_base
    {
        $1->appendChild($2);
        $$ = $1;
    }
    ;

collapse_spec:
      "(" IDENT ")" collapse_spec_base_list
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_postfix_expression"});
        node->addData("verb", *(new std::string("()")));
        
        // the "left" child
        ExprNode *left = new ExprNode({"ado_literal", "ado_ident"});
        left->addData("value", *(new std::string("collapse_stat")));
        node->appendChild("left", left);
        
        // the "right" child
        ExprNode *explist = new ExprNode("ado_expression_list");
        explist->appendChild($2); // stat goes first
        ExprNode *arglist = new ExprNode("ado_argument_expression_list");
        arglist->appendChild(explist);
        arglist->appendChild($4); // variable names or assignments follow
        
        node->appendChild("right", arglist);
        $$ = node;
    }
    ;

collapse_list:
      collapse_spec
    {
        ExprNode *node = new ExprNode("ado_expression_list");
        node->appendChild($1);
        $$ = node;
    }
    | collapse_list collapse_spec
    {
        $1->appendChild($2);
        $$ = $1;
    }
    ;

/* Helper constructs for recode */
recode_rule:
      IDENT
    | "(" IDENT "=" NUMBER ")" 
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_postfix_expression"});
        node->addData("verb", *(new std::string("()")));
        
        // the "left" child
        ExprNode *left = new ExprNode({"ado_literal", "ado_ident"});
        left->addData("value", *(new std::string("recode_rule_ident")));
        node->appendChild("left", left);
        
        // the "right" child
        ExprNode *explist = new ExprNode("ado_expression_list");
        explist->appendChild($4); // destination value goes first
        explist->appendChild($2);
        ExprNode *arglist = new ExprNode("ado_argument_expression_list");
        arglist->appendChild(explist);
        
        node->appendChild("right", arglist);
        $$ = node;
    }
    | "(" NUMBER "/" NUMBER "=" NUMBER ")" 
    {
        $3; // shut up, bison...

        ExprNode *node = new ExprNode({"ado_expression", "ado_postfix_expression"});
        node->addData("verb", *(new std::string("()")));
        
        // the "left" child
        ExprNode *left = new ExprNode({"ado_literal", "ado_ident"});
        left->addData("value", *(new std::string("recode_rule_range")));
        node->appendChild("left", left);
        
        // the "right" child
        ExprNode *explist = new ExprNode("ado_expression_list");
        explist->appendChild($6); // destination value goes first
        explist->appendChild($4); // then the upper range limit
        explist->appendChild($2); // then the lower range limit
        ExprNode *arglist = new ExprNode("ado_argument_expression_list");
        arglist->appendChild(explist);
        
        node->appendChild("right", arglist);
        $$ = node;
    }
    | "(" numlist "=" NUMBER ")" 
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_postfix_expression"});
        node->addData("verb", *(new std::string("()")));
        
        // the "left" child
        ExprNode *left = new ExprNode({"ado_literal", "ado_ident"});
        left->addData("value", *(new std::string("recode_rule_numlist")));
        node->appendChild("left", left);
        
        // the "right" child
        ExprNode *explist = new ExprNode("ado_expression_list");
        explist->appendChild($4); // destination value goes first
        ExprNode *arglist = new ExprNode("ado_argument_expression_list");
        arglist->appendChild(explist);
        arglist->appendChild($2); // this is flattened in the code generator
        
        node->appendChild("right", arglist);
        $$ = node;
    }
    ;

recode_rule_list:
      recode_rule
    {
        ExprNode *node = new ExprNode("ado_expression_list");
        node->appendChild($1);
        $$ = node;
    }
    | recode_rule_list recode_rule
    {
        $1->appendChild($2);
        $$ = $1;
    }
    ;

/* Helper constructs for gsort */
gsort_var:
      IDENT
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_postfix_expression"});
        node->addData("verb", *(new std::string("()")));
        node->appendChild("right", $1);
        
        ExprNode *left = new ExprNode({"ado_literal", "ado_ident"});
        left->addData("value", *(new std::string("asc")));
        node->appendChild("left", left);
        
        $$ = node;
    }
    | "+" IDENT
    {
        $1; // shut up, bison...
        
        ExprNode *node = new ExprNode({"ado_expression", "ado_postfix_expression"});
        node->addData("verb", *(new std::string("()")));
        node->appendChild("right", $2);
        
        ExprNode *left = new ExprNode({"ado_literal", "ado_ident"});
        left->addData("value", *(new std::string("asc")));
        node->appendChild("left", left);

        $$ = node;
    }
    | "-" IDENT
    {
        $1; // shut up, bison...
        
        ExprNode *node = new ExprNode({"ado_expression", "ado_postfix_expression"});
        node->addData("verb", *(new std::string("()")));
        node->appendChild("right", $2);
        
        ExprNode *left = new ExprNode({"ado_literal", "ado_ident"});
        left->addData("value", *(new std::string("desc")));
        node->appendChild("left", left);

        $$ = node;
    }
    ;

gsort_varlist:
      gsort_var
    {
        ExprNode *node = new ExprNode("ado_expression_list");
        node->appendChild($1);
        $$ = node;
    }
    | gsort_varlist gsort_var
    {
        $1->appendChild($2);
        $$ = $1;
    }
    ;

/* Helper constructs for lrtest */
modelspec:
      IDENT
    | "."
    | "(" varlist ")"
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_postfix_expression"});
        node->addData("verb", *(new std::string("()")));

        ExprNode *left = new ExprNode({"ado_literal", "ado_ident"});
        left->addData("value", *(new std::string("lrtest_term_list")));
        node->appendChild("left", left);

        ExprNode *arglist = new ExprNode("ado_argument_expression_list");
        arglist->appendChild($2);
        node->appendChild("right", arglist);
        
        $$ = node;
    }
    ;

modelspec_list:
      modelspec
    {
        ExprNode *node = new ExprNode("ado_expression_list");
        node->appendChild($1);
        $$ = node;
    }
    | modelspec_list modelspec
    {
        $1->appendChild($2);
        $$ = $1;
    }
    ;

/* Helper constructs for anova */
anova_nest_expression:
      cross_expression
    | anova_nest_expression "|" cross_expression
    {
        $2; // shut up, bison...
        
        ExprNode *node = new ExprNode({"ado_expression", "ado_anova_nest_expression"});
        node->addData("verb", *(new std::string("%anova_nest%")));
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        
        $$ = node;
    }
    ;

anova_error_expression:
      anova_nest_expression
    | anova_nest_expression "/"
    {
        $2; // shut up, bison...
        
        ExprNode *node = new ExprNode({"ado_expression", "ado_anova_error_expression"});
        node->addData("verb", *(new std::string("%anova_error%")));
        node->appendChild("left", $1);
        
        $$ = node;
    }
    ;

anova_term_list:
      anova_error_expression
    {
        ExprNode *node = new ExprNode("ado_expression_list");
        node->appendChild($1);
        $$ = node;
    }
    | anova_term_list anova_error_expression
    {
        $1->appendChild($2);
        $$ = $1;
    }
    ;

/*
 **************************************************************
 * The main expression grammar. Note that with the exception of
 * the special commands above, varlists are expressions
 * syntactically, even if they're not semantically.
 **************************************************************
*/

type_operator:
      BYTE
    | INT
    | LONG
    | FLOAT
    | DOUBLE
    | STRING_TYPE_SPEC
    ;

assignment_operator:
    "="
    ;

unary_operator:
      "-"
    | "+"
    | "!"
    ;

unary_factor_operator:
      CONT_OPERATOR
    | BASE_OPERATOR
    | IND_OPERATOR
    | OMIT_OPERATOR
    ;

power_operator:
    "^"
    ;

multiplication_operator:
      "*"
    | "/"
    ;

additive_operator:
      "+"
    | "-"
    ;

relational_operator:
      "<"
    | ">"
    | ">="
    | "<="
    ;

equality_operator:
      "=="
    | "!="
    ;

logical_operator:
      "&"
    | "|"
    ;

cross_operator:
      "##"
    | "#"
    ;

format_spec:
      STRING_FORMAT
    | NUMBER_FORMAT
    | DATETIME_FORMAT
    ;

literal_expression:
      IDENT
    | NUMBER
    | STRING_LITERAL
    | DATE
    | DATETIME
    | "." /* a numeric missing */
    | format_spec
    ;

primary_expression:
      literal_expression
    {
        $$ = $1;
    }
    | "(" expression ")"
    {
        $$ = $2;
    }
    | type_operator "(" expression_list ")"
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_type_expression"});
        node->addData("verb", *($1));
        node->appendChild("left", $3);

        $$ = node;
    }
    | type_operator IDENT
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_type_expression"});
        node->addData("verb", *($1));

        ExprNode *lst = new ExprNode("ado_expression_list");
        lst->appendChild($2);
        node->appendChild("left", lst);

        $$ = node;
    }
    ;

unary_factor_expression:
      primary_expression
    | unary_factor_operator primary_expression
    {
        $1->appendChild("left", $2);

        $$ = $1; // ExprNode constructed by the lexer, which is a bit of a hack
    }
    ;

cross_expression:
      unary_factor_expression
    | cross_expression cross_operator unary_factor_expression
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_cross_expression"});
        node->addData("verb", *($2));
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        $$ = node;
    }
    ;

postfix_expression:
      cross_expression
    | postfix_expression "[" additive_expression "]"
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_postfix_expression"});
        node->addData("verb", std::string("[]"));
        node->appendChild("left", $1);
        node->appendChild("right", $3);

        $$ = node;
    }
    | postfix_expression "(" ")" %prec "("
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_postfix_expression"});
        node->addData("verb", std::string("()"));
        node->appendChild("left", $1);

        $$ = node;
    }
    | postfix_expression "(" argument_expression_list ")"
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_postfix_expression"});
        node->addData("verb", std::string("()"));
        node->appendChild("left", $1);
        node->appendChild("right", $3);

        $$ = node;
    }
    ;

power_expression:
      postfix_expression %prec EXPONENT
    | power_expression power_operator postfix_expression %prec EXPONENT
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_arithmetic_expression", "ado_power_expression"});
        node->addData("verb", *($2));
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        $$ = node;
    }
    ;

unary_expression:
      power_expression
    | unary_operator power_expression
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_arithmetic_expression", "ado_unary_expression"});
        node->addData("verb", *($1));
        node->appendChild("right", $2);
        $$ = node;
    }
    ;

multiplication_expression:
      unary_expression
    | multiplication_expression multiplication_operator unary_expression
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_arithmetic_expression", "ado_multiplication_expression"});
        node->addData("verb", *($2));
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        $$ = node;
    }
    ;

additive_expression:
      multiplication_expression %prec "+"
    | additive_expression additive_operator multiplication_expression %prec "+"
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_arithmetic_expression", "ado_additive_expression"});
        node->addData("verb", *($2));
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        $$ = node;
    }
    ;

relational_expression:
      additive_expression %prec RELATIONAL
    | relational_expression relational_operator additive_expression %prec RELATIONAL
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_relational_expression"});
        node->addData("verb", *($2));
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        $$ = node;
    }
    ;

equality_expression:
      relational_expression
    | equality_expression equality_operator relational_expression
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_equality_expression"});
        node->addData("verb", *($2));
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        $$ = node;
    }
    ;

logical_expression:
      equality_expression
    | logical_expression logical_operator equality_expression
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_logical_expression"});
        node->addData("verb", *($2));
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        $$ = node;
    }
    ;

expression:
      logical_expression
    | logical_expression assignment_operator logical_expression
    {
        ExprNode *node = new ExprNode({"ado_expression", "ado_assignment_expression"});
        node->addData("verb", "=");
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        $$ = node;
    }
    ;

expression_list:
      expression
    {
        ExprNode *node = new ExprNode("ado_expression_list");
        node->appendChild($1);
        $$ = node;
    }
    | expression_list expression
    {
        $1->appendChild($2);
        $$ = $1;
    }
    ;

argument_expression_list:
      expression_list
    {
        ExprNode *node = new ExprNode("ado_argument_expression_list");
        node->appendChild($1);
        $$ = node;
    }
    | argument_expression_list "," expression_list
    {
        $1->appendChild($3);

        $$ = $1;
    }
    ;

/*
 **************************************************
 * Options and option lists
 **************************************************
 */

option_list:
      %empty
    {
        $$ = new ExprNode("ado_option_list");
    }
    | "," options
    {
        $$ = $2;
    }
    ;

options:
      option
    {
        ExprNode *node = new ExprNode("ado_option_list");
        node->appendChild($1);
        $$ = node;
    }
    | options option
    {
        $1->appendChild($2);
        $$ = $1;
    }
    ;

option:
      option_ident
    {
        ExprNode *node = new ExprNode("ado_option");
        node->appendChild("name", $1);

        $$ = node;
    }
    | option_ident "(" argument_expression_list ")"
    {
        ExprNode *node = new ExprNode("ado_option");
        node->appendChild("name", $1);
        node->appendChild("args", $3);

        $$ = node;
    }
    ;

/* these special command verbs sometimes (e.g., with "by")
 * have to be usable as options */
option_ident:
      IDENT
    | BY
    | BYSORT
    | XI
    | CAPTURE
    | QUIETLY
    | NOISILY
    | MERGE
    | COLLAPSE
    | RECODE
    | IVREGRESS
    | GSORT
    | LRTEST
    | ANOVA
    ;

/*
 **************************************************
 * The weight clause
 **************************************************
 */

weight_clause:
      %empty
    {
        $$ = new ExprNode("ado_weight_clause");
    }
    | WEIGHT_SPEC literal_expression "]"
    {
        $1->appendChild("right", $2);
        $$ = $1;
    }
    ;

/*
 **************************************************
 * The if clause
 **************************************************
 */

if_clause:
      %empty
    {
        $$ = new ExprNode("ado_if_clause");
    }
    | IF expression
    {
        ExprNode *node = new ExprNode("ado_if_clause");
        node->appendChild("if_expression", $2);

        $$ = node;
    }
    ;

/*
 **************************************************
 * The in clause
 **************************************************
 */

in_clause:
      %empty
    {
        $$ = new ExprNode("ado_in_clause");
    }
    | IN unary_expression "/" unary_expression
    {
        $3; // suppressing a stupid bison warning

        ExprNode *node = new ExprNode("ado_in_clause");
        node->appendChild("lower", $2);
        node->appendChild("upper", $4);

        $$ = node;
    }
    | IN unary_expression
    {
        ExprNode *node = new ExprNode("ado_in_clause");
        node->appendChild("upper", $2);

        $$ = node;
    }
    ;

/*
 **************************************************
 * The using clause
 **************************************************
 */

using_clause:
      %empty
    {
        $$ = new ExprNode("ado_using_clause");
    }
    | USING STRING_LITERAL
    {
        ExprNode *node = new ExprNode("ado_using_clause");
        node->appendChild("filename", $2);

        $$ = node;
    }
    | USING IDENT
    {
        ExprNode *node = new ExprNode("ado_using_clause");
        node->appendChild("filename", $2);

        $$ = node;
    }
    ;

%%

